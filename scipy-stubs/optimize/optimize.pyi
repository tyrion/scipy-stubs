# Stubs for scipy.optimize.optimize (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .linesearch import line_search_wolfe2 as line_search
from typing import Any, Optional

class MemoizeJac:
    fun: Any = ...
    jac: Any = ...
    x: Any = ...
    def __init__(self, fun: Any) -> None: ...
    def __call__(self, x: Any, *args: Any): ...
    def derivative(self, x: Any, *args: Any): ...

class OptimizeResult(dict):
    def __getattr__(self, name: Any): ...
    __setattr__: Any = ...
    __delattr__: Any = ...
    def __repr__(self): ...
    def __dir__(self): ...

class OptimizeWarning(UserWarning): ...

def rosen(x: Any): ...
def rosen_der(x: Any): ...
def rosen_hess(x: Any): ...
def rosen_hess_prod(x: Any, p: Any): ...
def fmin(func: Any, x0: Any, args: Any = ..., xtol: float = ..., ftol: float = ..., maxiter: Optional[Any] = ..., maxfun: Optional[Any] = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Optional[Any] = ..., initial_simplex: Optional[Any] = ...): ...
def approx_fprime(xk: Any, f: Any, epsilon: Any, *args: Any): ...
def check_grad(func: Any, grad: Any, x0: Any, *args: Any, **kwargs: Any): ...

class _LineSearchError(RuntimeError): ...

def fmin_bfgs(f: Any, x0: Any, fprime: Optional[Any] = ..., args: Any = ..., gtol: float = ..., norm: Any = ..., epsilon: Any = ..., maxiter: Optional[Any] = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Optional[Any] = ...): ...
def fmin_cg(f: Any, x0: Any, fprime: Optional[Any] = ..., args: Any = ..., gtol: float = ..., norm: Any = ..., epsilon: Any = ..., maxiter: Optional[Any] = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Optional[Any] = ...): ...
def fmin_ncg(f: Any, x0: Any, fprime: Any, fhess_p: Optional[Any] = ..., fhess: Optional[Any] = ..., args: Any = ..., avextol: float = ..., epsilon: Any = ..., maxiter: Optional[Any] = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Optional[Any] = ...): ...
def fminbound(func: Any, x1: Any, x2: Any, args: Any = ..., xtol: float = ..., maxfun: int = ..., full_output: int = ..., disp: int = ...): ...

class Brent:
    func: Any = ...
    args: Any = ...
    tol: Any = ...
    maxiter: Any = ...
    _mintol: float = ...
    _cg: float = ...
    xmin: Any = ...
    fval: Any = ...
    iter: int = ...
    funcalls: int = ...
    def __init__(self, func: Any, args: Any = ..., tol: float = ..., maxiter: int = ..., full_output: int = ...) -> None: ...
    brack: Any = ...
    def set_bracket(self, brack: Optional[Any] = ...) -> None: ...
    def get_bracket_info(self): ...
    def optimize(self) -> None: ...
    def get_result(self, full_output: bool = ...): ...

def brent(func: Any, args: Any = ..., brack: Optional[Any] = ..., tol: float = ..., full_output: int = ..., maxiter: int = ...): ...
def golden(func: Any, args: Any = ..., brack: Optional[Any] = ..., tol: Any = ..., full_output: int = ..., maxiter: int = ...): ...
def bracket(func: Any, xa: float = ..., xb: float = ..., args: Any = ..., grow_limit: float = ..., maxiter: int = ...): ...
def fmin_powell(func: Any, x0: Any, args: Any = ..., xtol: float = ..., ftol: float = ..., maxiter: Optional[Any] = ..., maxfun: Optional[Any] = ..., full_output: int = ..., disp: int = ..., retall: int = ..., callback: Optional[Any] = ..., direc: Optional[Any] = ...): ...
def brute(func: Any, ranges: Any, args: Any = ..., Ns: int = ..., full_output: int = ..., finish: Any = ..., disp: bool = ...): ...
def show_options(solver: Optional[Any] = ..., method: Optional[Any] = ..., disp: bool = ...): ...
