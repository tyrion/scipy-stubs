# Stubs for scipy.signal.ltisys (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

class LinearTimeInvariant:
    def __new__(cls, *system: Any, **kwargs: Any): ...
    inputs: Any = ...
    outputs: Any = ...
    _dt: Any = ...
    def __init__(self) -> None: ...
    @property
    def dt(self): ...
    @property
    def _dt_dict(self): ...
    @property
    def zeros(self): ...
    @property
    def poles(self): ...
    def _as_ss(self): ...
    def _as_zpk(self): ...
    def _as_tf(self): ...

class lti(LinearTimeInvariant):
    def __new__(cls, *system: Any): ...
    def __init__(self, *system: Any) -> None: ...
    def impulse(self, X0: Optional[Any] = ..., T: Optional[Any] = ..., N: Optional[Any] = ...): ...
    def step(self, X0: Optional[Any] = ..., T: Optional[Any] = ..., N: Optional[Any] = ...): ...
    def output(self, U: Any, T: Any, X0: Optional[Any] = ...): ...
    def bode(self, w: Optional[Any] = ..., n: int = ...): ...
    def freqresp(self, w: Optional[Any] = ..., n: int = ...): ...
    def to_discrete(self, dt: Any, method: str = ..., alpha: Optional[Any] = ...) -> None: ...

class dlti(LinearTimeInvariant):
    def __new__(cls, *system: Any, **kwargs: Any): ...
    dt: Any = ...
    def __init__(self, *system: Any, **kwargs: Any) -> None: ...
    @property
    def dt(self): ...
    @dt.setter
    _dt: Any = ...
    def dt(self, dt: Any) -> None: ...
    def impulse(self, x0: Optional[Any] = ..., t: Optional[Any] = ..., n: Optional[Any] = ...): ...
    def step(self, x0: Optional[Any] = ..., t: Optional[Any] = ..., n: Optional[Any] = ...): ...
    def output(self, u: Any, t: Any, x0: Optional[Any] = ...): ...
    def bode(self, w: Optional[Any] = ..., n: int = ...): ...
    def freqresp(self, w: Optional[Any] = ..., n: int = ..., whole: bool = ...): ...

class TransferFunction(LinearTimeInvariant):
    def __new__(cls, *system: Any, **kwargs: Any): ...
    _num: Any = ...
    _den: Any = ...
    def __init__(self, *system: Any, **kwargs: Any) -> None: ...
    def __repr__(self): ...
    @property
    def num(self): ...
    @num.setter
    outputs: int = ...
    inputs: int = ...
    def num(self, num: Any) -> None: ...
    @property
    def den(self): ...
    @den.setter
    def den(self, den: Any) -> None: ...
    num: Any = ...
    den: Any = ...
    def _copy(self, system: Any) -> None: ...
    def to_tf(self): ...
    def to_zpk(self): ...
    def to_ss(self): ...
    @staticmethod
    def _z_to_zinv(num: Any, den: Any): ...
    @staticmethod
    def _zinv_to_z(num: Any, den: Any): ...

class TransferFunctionContinuous(TransferFunction, lti):
    def to_discrete(self, dt: Any, method: str = ..., alpha: Optional[Any] = ...): ...

class TransferFunctionDiscrete(TransferFunction, dlti): ...

class ZerosPolesGain(LinearTimeInvariant):
    def __new__(cls, *system: Any, **kwargs: Any): ...
    _zeros: Any = ...
    _poles: Any = ...
    _gain: Any = ...
    def __init__(self, *system: Any, **kwargs: Any) -> None: ...
    def __repr__(self): ...
    @property
    def zeros(self): ...
    @zeros.setter
    outputs: int = ...
    inputs: int = ...
    def zeros(self, zeros: Any) -> None: ...
    @property
    def poles(self): ...
    @poles.setter
    def poles(self, poles: Any) -> None: ...
    @property
    def gain(self): ...
    @gain.setter
    def gain(self, gain: Any) -> None: ...
    poles: Any = ...
    zeros: Any = ...
    gain: Any = ...
    def _copy(self, system: Any) -> None: ...
    def to_tf(self): ...
    def to_zpk(self): ...
    def to_ss(self): ...

class ZerosPolesGainContinuous(ZerosPolesGain, lti):
    def to_discrete(self, dt: Any, method: str = ..., alpha: Optional[Any] = ...): ...

class ZerosPolesGainDiscrete(ZerosPolesGain, dlti): ...

class StateSpace(LinearTimeInvariant):
    __array_priority__: float = ...
    __array_ufunc__: Any = ...
    def __new__(cls, *system: Any, **kwargs: Any): ...
    _A: Any = ...
    _B: Any = ...
    _C: Any = ...
    _D: Any = ...
    def __init__(self, *system: Any, **kwargs: Any) -> None: ...
    def __repr__(self): ...
    def _check_binop_other(self, other: Any): ...
    def __mul__(self, other: Any): ...
    def __rmul__(self, other: Any): ...
    def __neg__(self): ...
    def __add__(self, other: Any): ...
    def __sub__(self, other: Any): ...
    def __radd__(self, other: Any): ...
    def __rsub__(self, other: Any): ...
    def __truediv__(self, other: Any): ...
    @property
    def A(self): ...
    @A.setter
    def A(self, A: Any) -> None: ...
    @property
    def B(self): ...
    @B.setter
    inputs: Any = ...
    def B(self, B: Any) -> None: ...
    @property
    def C(self): ...
    @C.setter
    outputs: Any = ...
    def C(self, C: Any) -> None: ...
    @property
    def D(self): ...
    @D.setter
    def D(self, D: Any) -> None: ...
    A: Any = ...
    B: Any = ...
    C: Any = ...
    D: Any = ...
    def _copy(self, system: Any) -> None: ...
    def to_tf(self, **kwargs: Any): ...
    def to_zpk(self, **kwargs: Any): ...
    def to_ss(self): ...

class StateSpaceContinuous(StateSpace, lti):
    def to_discrete(self, dt: Any, method: str = ..., alpha: Optional[Any] = ...): ...

class StateSpaceDiscrete(StateSpace, dlti): ...

def lsim2(system: Any, U: Optional[Any] = ..., T: Optional[Any] = ..., X0: Optional[Any] = ..., **kwargs: Any): ...
def lsim(system: Any, U: Any, T: Any, X0: Optional[Any] = ..., interp: bool = ...): ...
def impulse(system: Any, X0: Optional[Any] = ..., T: Optional[Any] = ..., N: Optional[Any] = ...): ...
def impulse2(system: Any, X0: Optional[Any] = ..., T: Optional[Any] = ..., N: Optional[Any] = ..., **kwargs: Any): ...
def step(system: Any, X0: Optional[Any] = ..., T: Optional[Any] = ..., N: Optional[Any] = ...): ...
def step2(system: Any, X0: Optional[Any] = ..., T: Optional[Any] = ..., N: Optional[Any] = ..., **kwargs: Any): ...
def bode(system: Any, w: Optional[Any] = ..., n: int = ...): ...
def freqresp(system: Any, w: Optional[Any] = ..., n: int = ...): ...

class Bunch:
    def __init__(self, **kwds: Any) -> None: ...

def place_poles(A: Any, B: Any, poles: Any, method: str = ..., rtol: float = ..., maxiter: int = ...): ...
def dlsim(system: Any, u: Any, t: Optional[Any] = ..., x0: Optional[Any] = ...): ...
def dimpulse(system: Any, x0: Optional[Any] = ..., t: Optional[Any] = ..., n: Optional[Any] = ...): ...
def dstep(system: Any, x0: Optional[Any] = ..., t: Optional[Any] = ..., n: Optional[Any] = ...): ...
def dfreqresp(system: Any, w: Optional[Any] = ..., n: int = ..., whole: bool = ...): ...
def dbode(system: Any, w: Optional[Any] = ..., n: int = ...): ...
