# Stubs for scipy.sparse.linalg.eigen.arpack.arpack (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from scipy.sparse.linalg.interface import LinearOperator
from typing import Any, Optional, Dict

DNAUPD_ERRORS: Dict[int, str]
ZNAUPD_ERRORS: Dict[int, str]
DSAUPD_ERRORS: Dict[int, str]

SNAUPD_ERRORS = DNAUPD_ERRORS
CNAUPD_ERRORS = ZNAUPD_ERRORS
SSAUPD_ERRORS = DSAUPD_ERRORS

class ArpackError(RuntimeError):
    def __init__(self, info: Any, infodict: Any = ...) -> None: ...

class ArpackNoConvergence(ArpackError):
    eigenvalues: Any = ...
    eigenvectors: Any = ...
    def __init__(self, msg: Any, eigenvalues: Any, eigenvectors: Any) -> None: ...

class _ArpackParams:
    resid: Any = ...
    sigma: int = ...
    v: Any = ...
    iparam: Any = ...
    mode: Any = ...
    n: Any = ...
    tol: Any = ...
    k: Any = ...
    maxiter: Any = ...
    ncv: Any = ...
    which: Any = ...
    tp: Any = ...
    info: Any = ...
    converged: bool = ...
    ido: int = ...
    def __init__(self, n: Any, k: Any, tp: Any, mode: int = ..., sigma: Optional[Any] = ..., ncv: Optional[Any] = ..., v0: Optional[Any] = ..., maxiter: Optional[Any] = ..., which: str = ..., tol: int = ...) -> None: ...
    def _raise_no_convergence(self) -> None: ...

class _SymmetricArpackParams(_ArpackParams):
    OP: Any = ...
    B: Any = ...
    bmat: str = ...
    OPa: Any = ...
    OPb: Any = ...
    A_matvec: Any = ...
    workd: Any = ...
    workl: Any = ...
    _arpack_solver: Any = ...
    _arpack_extract: Any = ...
    iterate_infodict: Any = ...
    extract_infodict: Any = ...
    ipntr: Any = ...
    def __init__(self, n: Any, k: Any, tp: Any, matvec: Any, mode: int = ..., M_matvec: Optional[Any] = ..., Minv_matvec: Optional[Any] = ..., sigma: Optional[Any] = ..., ncv: Optional[Any] = ..., v0: Optional[Any] = ..., maxiter: Optional[Any] = ..., which: str = ..., tol: int = ...) -> None: ...
    converged: bool = ...
    def iterate(self) -> None: ...
    def extract(self, return_eigenvectors: Any): ...

class _UnsymmetricArpackParams(_ArpackParams):
    OP: Any = ...
    B: Any = ...
    bmat: str = ...
    OPa: Any = ...
    OPb: Any = ...
    matvec: Any = ...
    workd: Any = ...
    workl: Any = ...
    _arpack_solver: Any = ...
    _arpack_extract: Any = ...
    iterate_infodict: Any = ...
    extract_infodict: Any = ...
    ipntr: Any = ...
    rwork: Any = ...
    def __init__(self, n: Any, k: Any, tp: Any, matvec: Any, mode: int = ..., M_matvec: Optional[Any] = ..., Minv_matvec: Optional[Any] = ..., sigma: Optional[Any] = ..., ncv: Optional[Any] = ..., v0: Optional[Any] = ..., maxiter: Optional[Any] = ..., which: str = ..., tol: int = ...) -> None: ...
    converged: bool = ...
    def iterate(self) -> None: ...
    def extract(self, return_eigenvectors: Any): ...

class SpLuInv(LinearOperator):
    M_lu: Any = ...
    shape: Any = ...
    dtype: Any = ...
    isreal: Any = ...
    def __init__(self, M: Any) -> None: ...
    def _matvec(self, x: Any): ...

class LuInv(LinearOperator):
    M_lu: Any = ...
    shape: Any = ...
    dtype: Any = ...
    def __init__(self, M: Any) -> None: ...
    def _matvec(self, x: Any): ...

class IterInv(LinearOperator):
    M: Any = ...
    dtype: Any = ...
    shape: Any = ...
    ifunc: Any = ...
    tol: Any = ...
    def __init__(self, M: Any, ifunc: Any = ..., tol: int = ...) -> None: ...
    def _matvec(self, x: Any): ...

class IterOpInv(LinearOperator):
    A: Any = ...
    M: Any = ...
    sigma: Any = ...
    OP: Any = ...
    shape: Any = ...
    ifunc: Any = ...
    tol: Any = ...
    def __init__(self, A: Any, M: Any, sigma: Any, ifunc: Any = ..., tol: int = ...) -> None: ...
    def _matvec(self, x: Any): ...
    @property
    def dtype(self): ...

def eigs(A: Any, k: int = ..., M: Optional[Any] = ..., sigma: Optional[Any] = ..., which: str = ..., v0: Optional[Any] = ..., ncv: Optional[Any] = ..., maxiter: Optional[Any] = ..., tol: int = ..., return_eigenvectors: bool = ..., Minv: Optional[Any] = ..., OPinv: Optional[Any] = ..., OPpart: Optional[Any] = ...): ...
def eigsh(A: Any, k: int = ..., M: Optional[Any] = ..., sigma: Optional[Any] = ..., which: str = ..., v0: Optional[Any] = ..., ncv: Optional[Any] = ..., maxiter: Optional[Any] = ..., tol: int = ..., return_eigenvectors: bool = ..., Minv: Optional[Any] = ..., OPinv: Optional[Any] = ..., mode: str = ...): ...
def svds(A: Any, k: int = ..., ncv: Optional[Any] = ..., tol: int = ..., which: str = ..., v0: Optional[Any] = ..., maxiter: Optional[Any] = ..., return_singular_vectors: bool = ...): ...
