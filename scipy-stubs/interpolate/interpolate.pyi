# Stubs for scipy.interpolate.interpolate (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .polyint import _Interpolator1D
from typing import Any, Optional

def lagrange(x: Any, w: Any): ...

class interp2d:
    tck: Any = ...
    bounds_error: Any = ...
    fill_value: Any = ...
    def __init__(self, x: Any, y: Any, z: Any, kind: str = ..., copy: bool = ..., bounds_error: bool = ..., fill_value: Optional[Any] = ...) -> None: ...
    def __call__(self, x: Any, y: Any, dx: int = ..., dy: int = ..., assume_sorted: bool = ...): ...

class interp1d(_Interpolator1D):
    bounds_error: Any = ...
    copy: Any = ...
    axis: Any = ...
    y: Any = ...
    _y: Any = ...
    x: Any = ...
    _kind: Any = ...
    fill_value: Any = ...
    x_bds: Any = ...
    _call: Any = ...
    _side: str = ...
    _ind: int = ...
    _x_shift: Any = ...
    _spline: Any = ...
    def __init__(self, x: Any, y: Any, kind: str = ..., axis: int = ..., copy: bool = ..., bounds_error: Optional[Any] = ..., fill_value: Any = ..., assume_sorted: bool = ...) -> None: ...
    @property
    def fill_value(self): ...
    @fill_value.setter
    _extrapolate: bool = ...
    _fill_value_orig: Any = ...
    def fill_value(self, fill_value: Any) -> None: ...
    def _call_linear_np(self, x_new: Any): ...
    def _call_linear(self, x_new: Any): ...
    def _call_nearest(self, x_new: Any): ...
    def _call_previousnext(self, x_new: Any): ...
    def _call_spline(self, x_new: Any): ...
    def _call_nan_spline(self, x_new: Any): ...
    def _evaluate(self, x_new: Any): ...
    def _check_bounds(self, x_new: Any): ...

class _PPolyBase:
    __slots__: Any = ...
    c: Any = ...
    x: Any = ...
    extrapolate: Any = ...
    axis: Any = ...
    def __init__(self, c: Any, x: Any, extrapolate: Optional[Any] = ..., axis: int = ...) -> None: ...
    def _get_dtype(self, dtype: Any): ...
    @classmethod
    def construct_fast(cls, c: Any, x: Any, extrapolate: Optional[Any] = ..., axis: int = ...): ...
    def _ensure_c_contiguous(self) -> None: ...
    def extend(self, c: Any, x: Any, right: Optional[Any] = ...): ...
    def __call__(self, x: Any, nu: int = ..., extrapolate: Optional[Any] = ...): ...

class PPoly(_PPolyBase):
    def _evaluate(self, x: Any, nu: Any, extrapolate: Any, out: Any) -> None: ...
    def derivative(self, nu: int = ...): ...
    def antiderivative(self, nu: int = ...): ...
    def integrate(self, a: Any, b: Any, extrapolate: Optional[Any] = ...): ...
    def solve(self, y: float = ..., discontinuity: bool = ..., extrapolate: Optional[Any] = ...): ...
    def roots(self, discontinuity: bool = ..., extrapolate: Optional[Any] = ...): ...
    @classmethod
    def from_spline(cls, tck: Any, extrapolate: Optional[Any] = ...): ...
    @classmethod
    def from_bernstein_basis(cls, bp: Any, extrapolate: Optional[Any] = ...): ...

class BPoly(_PPolyBase):
    def _evaluate(self, x: Any, nu: Any, extrapolate: Any, out: Any) -> None: ...
    def derivative(self, nu: int = ...): ...
    def antiderivative(self, nu: int = ...): ...
    def integrate(self, a: Any, b: Any, extrapolate: Optional[Any] = ...): ...
    c: Any = ...
    def extend(self, c: Any, x: Any, right: Optional[Any] = ...): ...
    @classmethod
    def from_power_basis(cls, pp: Any, extrapolate: Optional[Any] = ...): ...
    @classmethod
    def from_derivatives(cls, xi: Any, yi: Any, orders: Optional[Any] = ..., extrapolate: Optional[Any] = ...): ...
    @staticmethod
    def _construct_from_derivatives(xa: Any, xb: Any, ya: Any, yb: Any): ...
    @staticmethod
    def _raise_degree(c: Any, d: Any): ...

class NdPPoly:
    x: Any = ...
    c: Any = ...
    extrapolate: Any = ...
    def __init__(self, c: Any, x: Any, extrapolate: Optional[Any] = ...) -> None: ...
    @classmethod
    def construct_fast(cls, c: Any, x: Any, extrapolate: Optional[Any] = ...): ...
    def _get_dtype(self, dtype: Any): ...
    def _ensure_c_contiguous(self) -> None: ...
    def __call__(self, x: Any, nu: Optional[Any] = ..., extrapolate: Optional[Any] = ...): ...
    def _derivative_inplace(self, nu: Any, axis: Any): ...
    def _antiderivative_inplace(self, nu: Any, axis: Any): ...
    def derivative(self, nu: Any): ...
    def antiderivative(self, nu: Any): ...
    def integrate_1d(self, a: Any, b: Any, axis: Any, extrapolate: Optional[Any] = ...): ...
    def integrate(self, ranges: Any, extrapolate: Optional[Any] = ...): ...

class RegularGridInterpolator:
    method: Any = ...
    bounds_error: Any = ...
    fill_value: Any = ...
    grid: Any = ...
    values: Any = ...
    def __init__(self, points: Any, values: Any, method: str = ..., bounds_error: bool = ..., fill_value: Any = ...) -> None: ...
    def __call__(self, xi: Any, method: Optional[Any] = ...): ...
    def _evaluate_linear(self, indices: Any, norm_distances: Any, out_of_bounds: Any): ...
    def _evaluate_nearest(self, indices: Any, norm_distances: Any, out_of_bounds: Any): ...
    def _find_indices(self, xi: Any): ...

def interpn(points: Any, values: Any, xi: Any, method: str = ..., bounds_error: bool = ..., fill_value: Any = ...): ...

class _ppform(PPoly):
    coeffs: Any = ...
    breaks: Any = ...
    K: Any = ...
    fill: Any = ...
    a: Any = ...
    b: Any = ...
    def __init__(self, coeffs: Any, breaks: Any, fill: float = ..., sort: bool = ...) -> None: ...
    def __call__(self, x: Any): ...
    def _evaluate(self, x: Any, nu: Any, extrapolate: Any, out: Any): ...
    @classmethod
    def fromspline(cls, xk: Any, cvals: Any, order: Any, fill: float = ...): ...

def splmake(xk: Any, yk: Any, order: int = ..., kind: str = ..., conds: Optional[Any] = ...): ...
def spleval(xck: Any, xnew: Any, deriv: int = ...): ...
def spltopp(xk: Any, cvals: Any, k: Any): ...
def spline(xk: Any, yk: Any, xnew: Any, order: int = ..., kind: str = ..., conds: Optional[Any] = ...): ...
